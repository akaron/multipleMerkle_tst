pragma solidity ^0.5.2;                                                                                                      
//import "./SafeMath.sol";


contract Proof {
    //using SafeMath for uint256;
    address public owner;
    uint public numProofs;

    struct proofStruct{
        bytes32[] proof;
        bool[] isLeft;
        bytes32 targetLeaf;
        bytes32 merkleRoot;
    }
    mapping (uint => proofStruct) public userProofs;

    constructor () public {
        owner = msg.sender;
    }

    modifier ownerOnly() {
        require(msg.sender == owner);
        _;
    }

    // merkle tree and leaves
    function addProof(bytes32[] calldata proof, bool[] calldata isLeft, bytes32 targetLeaf, bytes32 merkleRoot) external ownerOnly {
        delete userProofs[numProofs];
                userProofs[numProofs] = proofStruct(proof, isLeft, targetLeaf, merkleRoot);                                          
        numProofs += 1;
    }

    function validateAllProofs() public view returns (bool){
        require(numProofs > 0);
        bool _result = true;
        for (uint i=0; i<numProofs; i++) {
            _result = _result && merkleTreeValidator(userProofs[i].proof, userProofs[i].isLeft, userProofs[i].targetLeaf, userProofs[i].merkleRoot);
        }
        return _result;
    }

    function merkleTreeValidator(bytes32[] memory proof, bool[] memory isLeft, bytes32 targetLeaf, bytes32 _merkleRoot) public pure returns (bool) {
        require(proof.length < 32);  // 2**32 ~ 4.3e9 leaves!
        require(proof.length == isLeft.length);

        bytes32 targetHash = targetLeaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofEle = proof[i];
            if (isLeft[i]) {
                    targetHash = keccak256(abi.encodePacked(proofEle, targetHash));
            } else if (!isLeft[i]) {
                    targetHash = keccak256(abi.encodePacked(targetHash, proofEle));
            } else {
                    return false;
            }       }                                                                                                                    
        return targetHash == _merkleRoot;
    }

    function resetData() public ownerOnly {
        numProofs = 0;
    }

}

// An example set of data to test merkleTreeValitator functions. The parameters are from a tree with 5 leaves, the parameters are "proof", "isLeft", "targetLeaf", "merkleRoot":

// ["0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb", "0x434d51cfeb80272378f4c3a8fd2824561c2cad9fce556ea600d46f20550976a6", "0xf1918e8562236eb17adc8502332f4c9c82bc14e19bfc0aa10ab674ff75b3d2f3"]
// [false, false, false]
// 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2
// 0xf04247a7619151ed5448e4be197d67efcf9530ad520c008739f8b303c902a085

// note:
// * data are from https://github.com/elevenbuckets/merkle_tree/blob/master/test_mk.js with leaves generated by hashes of 'a', 'b', 'c', 'd', 'e', and find the "proof" and "isLeft" for index 0 in the tree.
